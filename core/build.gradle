plugins {
  id "java"
  id "maven"
  id "idea"
  id "signing"

  id "net.ltgt.apt" version "0.7"
  id "com.github.ben-manes.versions" version "0.13.0"
  id "de.fuerstenau.buildconfig" version "1.1.4"
  id "com.jfrog.bintray" version "1.7.1"
  id "net.researchgate.release" version "2.4.1"
}
apply from: rootProject.file("scripts/buildArtifacts.gradle")

group 'com.clarifai.clarifai-api2'

dependencies {
  compile(
      "com.squareup.okhttp3:okhttp:$versions.okhttp",
      "com.google.code.gson:gson:2.7",
  )

  compileOnly(
      "com.jakewharton.auto.value:auto-value-annotations:$versions.autoValue",
      deps.nullityAnnotations,
      "com.github.kevinmost.auto-value-custom-hashcode-equals:adapter:$versions.customHashCodeEquals",
  )

  apt(
      "com.google.auto.value:auto-value:$versions.autoValue",
      "com.gabrielittner.auto.value:auto-value-with:1.0.0",
      "com.github.kevinmost.auto-value-custom-hashcode-equals:processor:$versions.customHashCodeEquals",
  )
}

def sensitiveFile = rootProject.file("sensitive.properties")
if (sensitiveFile.exists()) {
  mergePropertiesFileIntoProject(sensitiveFile)
  // Huge thanks to Cedric Beust for documenting these arcane and confusing options here:
  // http://beust.com/weblog/2015/07/13/the-long-and-arduous-road-to-jcenter-and-maven-bliss/
  def clarifai = [
      orgName: "Clarifai",
      description: "Clarifai Java API Client",
      github: "https://github.com/Clarifai/clarifai-java",
  ]

  // Why do we have to do this? I thought the plugin handled this for us... ¯\_(ツ)_/¯
  install {
    repositories.mavenInstaller {
      pom.project {
        name clarifai.orgName
        description clarifai.description
        url clarifai.github
        inceptionYear "2016"

        groupId project.group
        artifactId project.name
        version project.version

        licenses {
          license {
            name 'The Apache Software License, Version 2.0'
            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
            distribution 'repo'
          }
        }
        scm {
          url clarifai.github
          connection "${clarifai.github}.git"
        }
        developers {
          developer {
            name "${clarifai.orgName}, Inc."
          }
        }
      }
    }
  }
  bintray {
    user = project.jcenterUsername
    key = project.jcenterApiKey

    publish = true
    configurations = ["archives"]

    pkg {
      userOrg = clarifai.orgName.toLowerCase()
      repo = clarifai.orgName
      name = clarifai.orgName
      desc = clarifai.description

      licenses = ["Apache-2.0"]

      websiteUrl = clarifai.github
      issueTrackerUrl = "${clarifai.github}/issues"
      vcsUrl = "${clarifai.github}.git"

      version {
        name = project.version
        released = new Date()

        gpg { sign = true }

        mavenCentralSync {
          sync = true
          user = project.sonatypeUsername
          password = project.sonatypePassword
        }
      }
    }
  }
}


signing {
  required { currentlyDeploying() }
  sign configurations.archives
}

//noinspection GroovyUnusedAssignment
sourceCompatibility = JavaVersion.VERSION_1_7
//noinspection GroovyUnusedAssignment
targetCompatibility = JavaVersion.VERSION_1_7


buildConfig {
  packageName = "clarifai2"
  clsName = "BuildConfig"
}

release {
  failOnCommitNeeded = true
  failOnPublishNeeded = true
  failOnSnapshotDependencies = true
  failOnUnversionedFiles = true
  failOnUpdateNeeded = true
  revertOnFail = true
  preCommitText = ""
  preTagCommitMessage = ""
  tagCommitMessage = ""
  newVersionCommitMessage = ""
  tagTemplate = '${version}'
  versionPropertyFile = 'gradle.properties'
  versionProperties = []
  buildTasks = ['build']
  git {
    requireBranch = 'master'
    pushToRemote = 'public'
    commitVersionFileOnly = false
  }
}
afterReleaseBuild.dependsOn bintrayUpload

private boolean currentlyDeploying() {
  return gradle.taskGraph.hasTask("bintrayUpload")
}

private void mergePropertiesFileIntoProject(File file) {
  final def props = new Properties()
  props.load(new FileInputStream(file));
  props.each { project.ext.set(it.key, it.value) }
}